"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6306],{30433:function(e,t,n){n.d(t,{Z:function(){return i}});var a=n(67294),r=n(86010),o="tabItem_Ymn6";function i(e){var t=e.children,n=e.hidden,i=e.className;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(o,i),hidden:n},t)}},65559:function(e,t,n){n.d(t,{Z:function(){return m}});var a=n(83117),r=n(67294),o=n(86010),i=n(5730),l=n(20636),s=n(76602),p=n(63735),u="tabList__CuJ",d="tabItem_LNqP";function c(e){var t,n,i=e.lazy,c=e.block,m=e.defaultValue,f=e.values,h=e.groupId,y=e.className,k=r.Children.map(e.children,(function(e){if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),g=null!=f?f:k.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),b=(0,l.l)(g,(function(e,t){return e.value===t.value}));if(b.length>0)throw new Error('Docusaurus error: Duplicate values "'+b.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var w=null===m?m:null!=(t=null!=m?m:null==(n=k.find((function(e){return e.props.default})))?void 0:n.props.value)?t:k[0].props.value;if(null!==w&&!g.some((function(e){return e.value===w})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+w+'" but none of its children has the corresponding value. Available values are: '+g.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var N=(0,s.U)(),v=N.tabGroupChoices,C=N.setTabGroupChoices,T=(0,r.useState)(w),O=T[0],I=T[1],R=[],E=(0,p.o5)().blockElementScrollPositionUntilNextRender;if(null!=h){var P=v[h];null!=P&&P!==O&&g.some((function(e){return e.value===P}))&&I(P)}var x=function(e){var t=e.currentTarget,n=R.indexOf(t),a=g[n].value;a!==O&&(E(t),I(a),null!=h&&C(h,String(a)))},A=function(e){var t,n=null;switch(e.key){case"Enter":x(e);break;case"ArrowRight":var a,r=R.indexOf(e.currentTarget)+1;n=null!=(a=R[r])?a:R[0];break;case"ArrowLeft":var o,i=R.indexOf(e.currentTarget)-1;n=null!=(o=R[i])?o:R[R.length-1]}null==(t=n)||t.focus()};return r.createElement("div",{className:(0,o.Z)("tabs-container",u)},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":c},y)},g.map((function(e){var t=e.value,n=e.label,i=e.attributes;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:O===t?0:-1,"aria-selected":O===t,key:t,ref:function(e){return R.push(e)},onKeyDown:A,onClick:x},i,{className:(0,o.Z)("tabs__item",d,null==i?void 0:i.className,{"tabs__item--active":O===t})}),null!=n?n:t)}))),i?(0,r.cloneElement)(k.filter((function(e){return e.props.value===O}))[0],{className:"margin-top--md"}):r.createElement("div",{className:"margin-top--md"},k.map((function(e,t){return(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==O})}))))}function m(e){var t=(0,i.Z)();return r.createElement(c,(0,a.Z)({key:String(t)},e))}},52831:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return u},default:function(){return h},frontMatter:function(){return p},metadata:function(){return d},toc:function(){return m}});var a=n(83117),r=n(80102),o=(n(67294),n(3905)),i=n(65559),l=n(30433),s=["components"],p={title:"Type-Safe Relations"},u=void 0,d={unversionedId:"type-safe-relations",id:"type-safe-relations",title:"Type-Safe Relations",description:"Entity relations are mapped to entity references - instances of the entity that have at least the primary key available. This reference is stored in identity map, so you will get the same object reference when fetching the same document from database.",source:"@site/docs/type-safe-relations.md",sourceDirName:".",slug:"/type-safe-relations",permalink:"/docs/next/type-safe-relations",draft:!1,editUrl:"https://github.com/mikro-orm/mikro-orm/edit/master/docs/docs/type-safe-relations.md",tags:[],version:"current",lastUpdatedBy:"Martin Ad\xe1mek",lastUpdatedAt:1671203480,formattedLastUpdatedAt:"Dec 16, 2022",frontMatter:{title:"Type-Safe Relations"},sidebar:"docs",previous:{title:"Collections",permalink:"/docs/next/collections"},next:{title:"Entity Repository",permalink:"/docs/next/repositories"}},c={},m=[{value:"<code>Reference</code> wrapper",id:"reference-wrapper",level:2},{value:"<code>Loaded</code> type",id:"loaded-type",level:2},{value:"Assigning to <code>Reference</code> properties",id:"assigning-to-reference-properties",level:2},{value:"What is <code>Ref</code> (<code>IdentifiedReference</code>)?",id:"what-is-ref-identifiedreference",level:2}],f={toc:m};function h(e){var t=e.components,n=(0,r.Z)(e,s);return(0,o.kt)("wrapper",(0,a.Z)({},f,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Entity relations are mapped to entity references - instances of the entity that have at least the primary key available. This reference is stored in identity map, so you will get the same object reference when fetching the same document from database."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"@ManyToOne(() => Author)\nauthor!: Author; // the value is always instance of the `Author` entity\n")),(0,o.kt)("p",null,"You can check whether an entity is initialized via ",(0,o.kt)("inlineCode",{parentName:"p"},"wrap(entity).isInitialized()"),", and use ",(0,o.kt)("inlineCode",{parentName:"p"},"await wrap(entity).init()")," to initialize it. This will trigger database call and populate the entity, keeping the same reference in identity map."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const author = em.getReference(123);\nconsole.log(author.id); // accessing the id will not trigger any db call\nconsole.log(wrap(author).isInitialized()); // false\nconsole.log(author.name); // undefined\n\nawait wrap(author).init(); // this will trigger db call\nconsole.log(wrap(author).isInitialized()); // true\nconsole.log(author.name); // defined\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"isInitialized()")," method can be used for runtime checks, but that could end up being quite tedious - we can do better! Instead of manual checks for entity state, we can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"Reference")," wrapper."),(0,o.kt)("h2",{id:"reference-wrapper"},(0,o.kt)("inlineCode",{parentName:"h2"},"Reference")," wrapper"),(0,o.kt)("p",null,"When you define ",(0,o.kt)("inlineCode",{parentName:"p"},"@ManyToOne")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"@OneToOne")," properties on your entity, TypeScript compiler will think that desired entities are always loaded:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"@Entity()\nexport class Book {\n\n  @PrimaryKey()\n  id!: number;\n\n  @ManyToOne()\n  author!: Author;\n\n  constructor(author: Author) {\n    this.author = author;\n  }\n\n}\n\nconst book = await em.findOne(Book, 1);\nconsole.log(book.author instanceof Author); // true\nconsole.log(wrap(book.author).isInitialized()); // false\nconsole.log(book.author.name); // undefined as `Author` is not loaded yet\n")),(0,o.kt)("p",null,"You can overcome this issue by using the ",(0,o.kt)("inlineCode",{parentName:"p"},"Reference")," wrapper. It simply wraps the entity, defining ",(0,o.kt)("inlineCode",{parentName:"p"},"load(): Promise<T>")," method that will first lazy load the association if not already available. You can also use ",(0,o.kt)("inlineCode",{parentName:"p"},"unwrap(): T")," method to access the underlying entity without loading it."),(0,o.kt)("p",null,"You can also use ",(0,o.kt)("inlineCode",{parentName:"p"},"load<K extends keyof T>(prop: K): Promise<T[K]>"),", which works like ",(0,o.kt)("inlineCode",{parentName:"p"},"load()")," but returns the specified property."),(0,o.kt)(i.Z,{groupId:"entity-def",defaultValue:"reflect-metadata",values:[{label:"reflect-metadata",value:"reflect-metadata"},{label:"ts-morph",value:"ts-morph"},{label:"EntitySchema",value:"entity-schema"}],mdxType:"Tabs"},(0,o.kt)(l.Z,{value:"reflect-metadata",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Book.ts"',title:'"./entities/Book.ts"'},"import { Entity, Ref, ManyToOne, PrimaryKey, ref } from '@mikro-orm/core';\n\n@Entity()\nexport class Book {\n\n  @PrimaryKey()\n  id!: number;\n\n  @ManyToOne(() => Author, { ref: true })\n  author: Ref<Author>;\n\n  constructor(author: Author) {\n    this.author = ref(author);\n  }\n\n}\n"))),(0,o.kt)(l.Z,{value:"ts-morph",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Book.ts"',title:'"./entities/Book.ts"'},"import { Entity, Ref, ManyToOne, PrimaryKey, Reference } from '@mikro-orm/core';\n\n@Entity()\nexport class Book {\n\n  @PrimaryKey()\n  id!: number;\n\n  @ManyToOne()\n  author: Ref<Author>;\n\n  constructor(author: Author) {\n    this.author = ref(author);\n  }\n\n}\n"))),(0,o.kt)(l.Z,{value:"entity-schema",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Book.ts"',title:'"./entities/Book.ts"'},"export interface IBook {\n  id: number;\n  author: Ref<Author>;\n}\n\nexport const Book = new EntitySchema<IBook>({\n  name: 'Book',\n  properties: {\n    id: { type: Number, primary: true },\n    author: { entity: () => Author, ref: true },\n  },\n});\n")))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const book = await em.findOne(Book, 1);\nconsole.log(book.author instanceof Reference); // true\nconsole.log(wrap(book.author).isInitialized()); // false\nconsole.log(book.author.name); // type error, there is no `name` property\nconsole.log(book.author.unwrap().name); // undefined as author is not loaded\nconsole.log(await book.author.load('name')); // ok, loading the author first\nconsole.log((await book.author.load()).name); // ok, author already loaded\nconsole.log(book.author.unwrap().name); // ok, author already loaded\n")),(0,o.kt)("p",null,"There are also ",(0,o.kt)("inlineCode",{parentName:"p"},"getEntity()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"getProperty()")," methods that are synchronous getters, that will first check if the wrapped entity is initialized, and if not, it will throw and error."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const book = await em.findOne(Book, 1);\nconsole.log(book.author instanceof Reference); // true\nconsole.log(wrap(book.author).isInitialized()); // false\nconsole.log(book.author.getEntity()); // Error: Reference<Author> 123 not initialized\nconsole.log(book.author.getProperty('name')); // Error: Reference<Author> 123 not initialized\nconsole.log(await book.author.load('name')); // ok, loading the author first\nconsole.log(book.author.getProperty('name')); // ok, author already loaded\n")),(0,o.kt)("p",null,"If you use different metadata provider than ",(0,o.kt)("inlineCode",{parentName:"p"},"TsMorphMetadataProvider")," (e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"ReflectMetadataProvider"),"), you will also need to explicitly set ",(0,o.kt)("inlineCode",{parentName:"p"},"ref")," parameter:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ref")," option is an alias for ",(0,o.kt)("inlineCode",{parentName:"p"},"wrappedReference"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"Ref")," is an alias for ",(0,o.kt)("inlineCode",{parentName:"p"},"IdentifiedReference")," type, both added in v5.5.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"@ManyToOne(() => Author, { ref: true })\nauthor!: Ref<Author>;\n")),(0,o.kt)("h2",{id:"loaded-type"},(0,o.kt)("inlineCode",{parentName:"h2"},"Loaded")," type"),(0,o.kt)("p",null,"If you check the return type of ",(0,o.kt)("inlineCode",{parentName:"p"},"em.find")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"em.findOne")," methods, you might be a bit confused - instead of the entity, they return ",(0,o.kt)("inlineCode",{parentName:"p"},"Loaded")," type:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// res1 is of type `Loaded<User, never>[]`\nconst res1 = await em.find(User, {});\n\n// res2 is of type `Loaded<User, 'identity' | 'friends'>[]`\nconst res2 = await em.find(User, {}, { populate: ['identity', 'friends'] });\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"User")," entity is defined as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { Entity, PrimaryKey, ManyToOne, OneToOne, Collection, Ref, ref } from '@mikro-orm/core';\n\n@Entity()\nexport class User {\n\n  @PrimaryKey()\n  id!: number;\n\n  @ManyToOne(() => Identity)\n  identity: Ref<Identity>;\n\n  @ManyToMany(() => User)\n  friends = new Collection<User>(this);\n\n  constructor(identity: Identity) {\n    this.identity = ref(identity);\n  }\n\n}\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Loaded")," type will represent what relations of the entity are populated, and will add a special ",(0,o.kt)("inlineCode",{parentName:"p"},"$")," symbol to them, allowing for type-safe synchronous access to the loaded properties. This works great in combination with the ",(0,o.kt)("inlineCode",{parentName:"p"},"Reference")," wrapper:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"If you don't like symbols with magic names like ",(0,o.kt)("inlineCode",{parentName:"p"},"$"),", you can as well use the ",(0,o.kt)("inlineCode",{parentName:"p"},"get()")," method, which is an alias for it.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// res is of type `Loaded<User, 'identity'>`\nconst user = await em.findOneOrFail(User, 1, { populate: ['identity'] });\n\n// instead of the async `await user.identity.load()` call that would ensure the relation is loaded\n// you can use the dynamically added `$` symbol for synchronous and type-safe access to it:\nconsole.log(user.identity.$.email);\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"If you'd omit the ",(0,o.kt)("inlineCode",{parentName:"p"},"populate")," hint, type of ",(0,o.kt)("inlineCode",{parentName:"p"},"user")," would be ",(0,o.kt)("inlineCode",{parentName:"p"},"Loaded<User, never>")," and the ",(0,o.kt)("inlineCode",{parentName:"p"},"user.identity.$")," symbol wouldn't be available - such call would end up with compilation error.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// if we try without the populate hint, the type is `Loaded<User, never>`\nconst user2 = await em.findOneOrFail(User, 2);\n\n// TS2339: Property '$' does not exist on type '{ id: number; } & Reference'.\nconsole.log(user.identity.$.email);\n")),(0,o.kt)("p",null,"Same works for the ",(0,o.kt)("inlineCode",{parentName:"p"},"Collection")," wrapper, that offers runtime methods ",(0,o.kt)("inlineCode",{parentName:"p"},"isInitialized"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"loadItems")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"init"),", as well as the type-safe ",(0,o.kt)("inlineCode",{parentName:"p"},"$")," symbol."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// res is of type `Loaded<User, 'friends'>`\nconst user = await em.findOneOrFail(User, 1, { populate: ['friends'] });\n\n// instead of the async `await user.friends.loadItems()` call that would ensure the collection items are loaded\n// you can use the dynamically added `$` symbol for synchronous and type-safe access to it:\nfor (const friend of user.friends.$) {\n  console.log(friend.email);\n}\n")),(0,o.kt)("p",null,"You can also use the ",(0,o.kt)("inlineCode",{parentName:"p"},"Loaded")," type in your own methods, to require on type level that some relations will be populated:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"function checkIdentity(user: Loaded<User, 'identity'>) {\n  if (!user.idenity.$.email.includes('@')) {\n    throw new Error(`That's a weird e-mail!`);\n  }\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// works\nconst u1 = await em.findOneOrFail(User, 2, { populate: ['identity'] });\ncheckIdentity(u1);\n\n// fails\nconst u2 = await em.findOneOrFail(User, 2);\ncheckIdentity(u2);\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Keep in mind this is all just a type-level information, you can easily trick it via type assertions.")),(0,o.kt)("h2",{id:"assigning-to-reference-properties"},"Assigning to ",(0,o.kt)("inlineCode",{parentName:"h2"},"Reference")," properties"),(0,o.kt)("p",null,"When you define the property as ",(0,o.kt)("inlineCode",{parentName:"p"},"Reference")," wrapper, you will need to assign the ",(0,o.kt)("inlineCode",{parentName:"p"},"Reference")," instance to it instead of the entity. You can convert any entity to a ",(0,o.kt)("inlineCode",{parentName:"p"},"Reference")," wrapper via ",(0,o.kt)("inlineCode",{parentName:"p"},"ref(entity)"),", or use ",(0,o.kt)("inlineCode",{parentName:"p"},"wrapped")," option of ",(0,o.kt)("inlineCode",{parentName:"p"},"em.getReference()"),":"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("inlineCode",{parentName:"p"},"ref(e)")," is a shortcut for ",(0,o.kt)("inlineCode",{parentName:"p"},"wrap(e).toReference()"),", which is the same as ",(0,o.kt)("inlineCode",{parentName:"p"},"Reference.create(e)"),".")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { ref } from '@mikro-orm/core';\n\nconst book = await em.findOne(Book, 1);\nconst repo = em.getRepository(Author);\n\nbook.author = repo.getReference(2, { wrapped: true });\n\n// same as:\nbook.author = ref(repo.getReference(2));\nawait em.flush();\n")),(0,o.kt)("p",null,"Since v5 we can also create entity references without access to ",(0,o.kt)("inlineCode",{parentName:"p"},"EntityManager"),". This can be handy if you want to create a reference from inside entity constructor:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"@Entity()\nexport class Book {\n\n  @ManyToOne(() => Author, { ref: true })\n  author!: Ref<Author>;\n\n  constructor(authorId: number) {\n    this.author = Reference.createFromPK(Author, authorId);\n  }\n\n}\n")),(0,o.kt)("p",null,"Another way is to use ",(0,o.kt)("inlineCode",{parentName:"p"},"toReference()")," method available as part of ",(0,o.kt)("a",{parentName:"p",href:"/docs/next/entity-helper#wrappedentity-and-wrap-helper"},(0,o.kt)("inlineCode",{parentName:"a"},"WrappedEntity")," interface"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const author = new Author(...)\nbook.author = wrap(author).toReference();\n")),(0,o.kt)("p",null,"If the reference already exist, you can also re-assign to it via ",(0,o.kt)("inlineCode",{parentName:"p"},"set()")," method:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"book.author.set(new Author(...));\n")),(0,o.kt)("h2",{id:"what-is-ref-identifiedreference"},"What is ",(0,o.kt)("inlineCode",{parentName:"h2"},"Ref")," (",(0,o.kt)("inlineCode",{parentName:"h2"},"IdentifiedReference"),")?"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Ref")," is an intersection type that adds primary key property to the ",(0,o.kt)("inlineCode",{parentName:"p"},"Reference")," interface. It allows to get the primary key from ",(0,o.kt)("inlineCode",{parentName:"p"},"Reference")," instance directly."),(0,o.kt)("p",null,"By default, we try to detect the PK by checking if a property with a known name exists. We check for those in order: ",(0,o.kt)("inlineCode",{parentName:"p"},"_id"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"uuid"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"id")," - with a way to manually set the property name via ",(0,o.kt)("inlineCode",{parentName:"p"},"PrimaryKeyProp")," symbol (",(0,o.kt)("inlineCode",{parentName:"p"},"[PrimaryKeyProp]?: 'foo';"),"). "),(0,o.kt)("p",null,"We can also override this via second generic type argument."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const book = await em.findOne(Book, 1);\nconsole.log(book.author.id); // ok, returns the PK\n")),(0,o.kt)("p",null,"You can also have non-standard primary key:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"author: Ref<Author, 'myPrimaryKey'>;\n\nconst book = await em.findOne(Book, 1);\nconsole.log(book.author.myPrimaryKey); // ok, returns the PK\n")),(0,o.kt)("p",null,"For MongoDB, define the PK generic type argument as ",(0,o.kt)("inlineCode",{parentName:"p"},"'id' | '_id'")," to access both ",(0,o.kt)("inlineCode",{parentName:"p"},"string")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"ObjectId")," PK values:"),(0,o.kt)(i.Z,{groupId:"entity-def",defaultValue:"reflect-metadata",values:[{label:"reflect-metadata",value:"reflect-metadata"},{label:"ts-morph",value:"ts-morph"},{label:"EntitySchema",value:"entity-schema"}],mdxType:"Tabs"},(0,o.kt)(l.Z,{value:"reflect-metadata",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Book.ts"',title:'"./entities/Book.ts"'},"@Entity()\nexport class Book {\n\n  @PrimaryKey()\n  _id!: ObjectId;\n\n  @SerializedPrimaryKey()\n  id!: string;\n\n  @ManyToOne(() => Author, { ref: true })\n  author!: Ref<Author, 'id' | '_id'>;\n\n}\n"))),(0,o.kt)(l.Z,{value:"ts-morph",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Book.ts"',title:'"./entities/Book.ts"'},"@Entity()\nexport class Book {\n\n  @PrimaryKey()\n  _id!: ObjectId;\n\n  @SerializedPrimaryKey()\n  id!: string;\n\n  @ManyToOne()\n  author!: Ref<Author, 'id' | '_id'>;\n\n}\n"))),(0,o.kt)(l.Z,{value:"entity-schema",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Book.ts"',title:'"./entities/Book.ts"'},"export interface IBook {\n  _id: ObjectId;\n  id: string;\n  author: Ref<IAuthor, 'id' | '_id'>;\n}\n\nexport const Book = new EntitySchema<IBook>({\n  name: 'Book',\n  properties: {\n    _id: { type: 'ObjectId', primary: true },\n    id: { type: String, serializedPrimaryKey: true },\n    author: { entity: 'Author', ref: true },\n  },\n});\n")))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const book = await em.findOne(Book, 1);\nconsole.log(book.author.id); // ok, returns string PK\nconsole.log(book.author._id); // ok, returns ObjectId PK\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"As opposed to ",(0,o.kt)("inlineCode",{parentName:"p"},"wrap(e).init()")," which always refreshes the entity, ",(0,o.kt)("inlineCode",{parentName:"p"},"Reference.load()")," method will query the database only if the entity is not already loaded in Identity Map.")))}h.isMDXComponent=!0},3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=p(n),m=r,f=c["".concat(s,".").concat(m)]||c[m]||d[m]||o;return n?a.createElement(f,i(i({ref:t},u),{},{components:n})):a.createElement(f,i({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"}}]);